---
title: Grapevine xf Analysis 5
author: Daniel Turek
output: html_document
references:
  - id: tibbits14
    title: Automated factor slice sampling
    author:
    - family: Tibbits
      given: Matthew M
    - family: Groendyke
      given: Chris
    - family: Haran
      given: Murali
    - family: Liechty
      given: John C
    container-title: Journal of Computational and Graphical Statistics
    volume: 23
    issue: 2
    publisher: Taylor & Francis
    page: 543-563
    type: article-journal
    issued:
      year: 2014
---

<!---
https://danielturek.github.io/zeilinger_grapevine/analysis5.html
-->


```{r, include = FALSE}
setwd('~/github/zeilinger_grapevine/')
```

\   

### Updates in Analysis 5

\   

- Added probabilistic transmission models for bacteria at source plant
test sites, and for transmission of bacteria to vectors.
There is enough information in the data to support different
probabilities for each genotype.

- Updated Hierarchical Model (mathematical) description, to describe new 
probabilistic transmission models.

- Increased number of MCMC iterations from 50,000 to 110,000 to support
additional parameters (with burnin of 10,000).  MCMC runtime is still
very manageable.

- These changes in the model gave rise to many new and interesting
"significant" results.  It's worth looking carefully again at all the results sections.

- Updated Interpretations section, to reflect new posterior results of all 
model parameters.

- New Posterior Density Plots added, to compare source plant 
transmission probabilities (DSF vs. WT), and vector transmission 
probabilities (DSF vs. WT).

- Updated Hierarchical Plots, now shows a more accurate
depiction of probability of infection as a function of vector xf
concentration.  I believe this will better agree with the results from
the GLMM.


\   

### Updates in Analysis 4

\   

- New hierarchical plots added

\   

### Updates in Analysis 3 

\  

- Using new `dsf_data_for_nimble.rds` data file:
    - Corrected (switched) designations of DSF and WT genotypes 
    - Data uses method for estimating the xf concentration in vectors from the qPCR test 

- Interpretations section has beed carefully updated and revised, since most of the
  results regarding DSF and WT genotypes have switched.  In addition,
  a number of the other numerical results have changed.  

- New predictions included for probability of infection.  In addition to
  predicting (for each genotype) at distance = 0, we also collect
  samples of probability of infection for *all* plants, which is
  representative of *all* distances.  Summary statistics and posterior
  density plots for both types of predictions are included, which have
  explanable differences, but show nice agreement.  

\   



### Updates in Analysis 2

\  

- Vector xf concentration 
  $(\lambda^i_{vector})$ a modelled as a linear function of the source
  plant xf concentration $(\lambda^i_{plant})$.  Further, this linear
  relationship includes an interaction with genotype, so we separately
  model this linear relationship for each source plant genotype.

- Tried introducing a probabilistic model for whether the vectors
  acquire *any* xf bacteria from the source plant, as a function of
  plant genotype, to account for the "patchiness" of the bacteria in
  DSF plants.  However, this introduced a lack of identfyability
  between the probability of *transmitting* bacteria to the vectors (not
  currently in the model) and the probability of *observing* bacteria
  in the vectors (in the model).  So this probabilistic model for
  transmission from source plants to vectors was removed.

- The model for test plant infection was augmented to include a
  dependence on plant genotype.

- Simplified the parameterizations of interaction terms, for better
  interpretability.  The mathematical description of the hierarchical model more clearly 
  presents the biological processes for genotype DSF and WT
  plants.  And more clear descriptions for the interpretation of results.

- Make use of a new joint sampling algorithm avaialble in NIMBLE, the
  automated factor slice sampler [@tibbits14].  Although this increases runtime, it
  is extremely effective at sampling highly correlated groups of parameters.

- Predictive nodes are added to predict test plant infection, for the
  following two cases:
    - genotype = DSF, distance = 0
    - genotype = WT, distance = 0

\   

### Modeling Decisions 

\  

##### Vector xf is linear in source plant xf, by genotype (updated v2)

The xf concentration in the vectors
$(\lambda^i_{vector})$ is modeled as a linear function of the xf concentration in the
source plant $(\lambda^i_{source\ plant})$.  However, this linear
relationship is distinct for each genotype.

For genotype DSF plants:
$$\lambda^i_{vector} = \beta_5 + \beta_7 \cdot \lambda^i_{source\
plant}$$

and for genotype DSF plants:
$$\lambda^i_{vector} = \beta_6 + \beta_8 \cdot \lambda^i_{source\
plant}$$

This allows us to study how the linear relationship between source plant xf
concentration and vector xf concentation varies for each genotype.

\   

##### Source plant and vector observation processes 

To model the imperfect detection of xf bacteria in the source plants and 
vectors, I used a fixed (and separate) probability of detection for 
each.  When measuring the xf concentration in each source plant, there's 
a $p_{obs.\ source\ plant}$ probability of a positive detection (e.g.,
a non-zero measurement).

Similarly, when doing the PCR test to 
measure the xf concentration in each vector, there's 
a $p_{obs.\ vector}$ probability of a positive detection.  Each of
these probabilities of detection are unknown model parameters.

To implement these detection processes, additional binary latent variables are
introduced into the model.  The binary-valued $z^i_{source\ plant}$ and $z^i_{vector}$
variables indicate whether a positive detection was made in each source
plant or vector.

\   

##### Test plant infection process (updated v2)

Probabiliy of infection for the test plants is modeled (on the logit
scale) as a linear function of the vector xf concentration, as well as
a constant term for each plant genotype, as:

$$\text{logit}(p^i_{infect}) = \beta_9 \cdot \text{genotype}_{DSF} +
\beta_{10} \cdot \text{genotype}_{WT} + \beta_{11} \cdot  \lambda^i_{vector}$$

This sheds light on differences between the two plant genotypes, although there is still
not significant effect from the vector xf concentration.


\  

##### Plant Random Effects 

The plant random effects $(\alpha_{plant\ ID})$ were removed from the 
model, since there isn't enough data to support them. 
Specifically, with only 97 observations from 51 unique plants,
there aren't enough observations from each plant to identify the random 
effects.  Including them, sampling of the random effects trades off with the 
genotype fixed effects, and the model never converges. 

\   


### Hierarchical Model (updated v5) 

\  

$$
\begin{align}
\text{Priors:} \\
\beta_{1,...,11} &\sim Normal(0, \sigma = 10000) \\
p_{obs.\ source\ plant},\ p_{obs.\ vector} &\sim Uniform(0, 1) \\
p_{trans.\ DSF\ source\ plant},\ p_{trans.\ WT\ source\ plant} &\sim Uniform(0, 1) \\
p_{trans.\ DSF\ vector},\ p_{trans.\ WT\ vector} &\sim Uniform(0, 1) \\
\ \\
\text{Biological model (DSF source plants) (probabilistic transmission new v5):} \\
z^i_{trans.\ DSF\ source\ plant} &\sim Bernoulli(p_{trans.\ DSF\ source\ plant}) \\
\lambda^i_{DSF\ source\ plant} &= z^i_{trans.\ DSF\ source\ plant}
\cdot \exp(\beta_1 + \beta_3 \cdot distance^i) \\
z^i_{trans.\ DSF\ vector} &\sim Bernoulli(p_{trans.\ DSF\ vector}) \\
\lambda^i_{vector} &= z^i_{trans.\ DSF\ vector} \cdot (\beta_5 + \beta_7 \cdot \lambda^i_{DSF\ source\ plant}) \\
\ \\
\text{Biological model (WT source plants) (probabilistic transmission new v5):} \\
z^i_{trans.\ WT\ source\ plant} &\sim Bernoulli(p_{trans.\ WT\ source\ plant}) \\
\lambda^i_{WT\ source\ plant} &= z^i_{trans.\ WT\ source\ plant}
\cdot \exp(\beta_2 + \beta_4 \cdot distance^i) \\
z^i_{trans.\ WT\ vector} &\sim Bernoulli(p_{trans.\ WT\ vector}) \\
\lambda^i_{vector} &= z^i_{trans.\ DSF\ vector} \cdot (\beta_6 + \beta_8 \cdot \lambda^i_{WT\ source\ plant}) \\
\ \\
\text{Source plant observation model:} \\
z^i_{obs.\ source\ plant} &\sim Bernoulli(p_{obs.\ source\ plant}) \\
xf^i_{source\ plant} &\sim Poisson(z^i_{obs.\ source\ plant} \cdot \lambda^i_{source\ plant}) \\
\ \\
\text{Vector observation model:} \\
z^i_{obs.\ vector} &\sim Bernoulli(p_{obs.\ vector}) \\
xf^i_{vector} &\sim Poisson(z^i_{obs.\ vector} \cdot \lambda^i_{vector}) \\
\ \\
\text{Test plant infection model:} \\
\text{logit}(p^i_{infect}) &= \beta_9 \cdot \text{genotype}_{DSF} +
\beta_{10} \cdot \text{genotype}_{WT} + \beta_{11} \cdot  
\lambda^i_{vector} \\  
infected^i &\sim Bernoulli(p^i_{infect}) \\
\end{align}
$$

\   



### Data Setup

\  

A few manipulations are done of the input data.

```{r }
dsf <- readRDS('data/dsf_data_for_nimble.rds')   ## original data file
```

We specify covariates:

- $genotype_{dsf}=1$ when genotype = DSF, and 0 otherwise
- $genotype_{wt}=1$ when genotype = WT, and 0 otherwise 

```{r }
constants <- list(
    N = dsf$dsfData$N,
    distance = dsf$dsfData$distance,
    ## in original dataset: genotype 1=DSF, 2=WT
    genotype_dsf = ifelse(dsf$dsfData$genotype==1, 1, 0),   ## indicator for DSF
    genotype_wt  = ifelse(dsf$dsfData$genotype==2, 1, 0)    ## indicator for WT
    ## note: test plants are all WT genotype
)
```

The values of the $xf_{vector}$ data are truncated to be integers, for
compatibility with the Poisson distribution.

```{r }
data <- list(
    xf_source_plant = dsf$dsfData$xf_source_plant,
    xf_vector = floor(dsf$dsfData$xf_vector),   ## change to integers
    infected = dsf$dsfData$infected
)
```

We also create three additional vectors of indicies.  Thes contain the
indicies of the observed (non-NA) data, for each of $xf_{source\
plant}$, $xf_{vector}$, and $infected$.  These will be used in the
model to skip creating posterior predictive nodes, which speed
up the MCMC and overall mixing considerably.

```{r }
## indices of observed values for each set of data:
constants$obs_ind_plant <- which(!is.na(data$xf_source_plant))
constants$obs_ind_vector <- which(!is.na(data$xf_vector))
constants$obs_ind_infected <- which(!is.na(data$infected))

## and the counts of each:
constants$N_obs_plant <- length(constants$obs_ind_plant)
constants$N_obs_vector <- length(constants$obs_ind_vector)
constants$N_obs_infected <- length(constants$obs_ind_infected)
```


```{r include=FALSE, eval=FALSE}
save(dsf, data, constants, file = 'data/temp5.RData')

setwd('~/github/zeilinger_grapevine/')
load('data/temp5.RData')
```


\   

### Model and MCMC  (updated v5)

\  

Use <a href="https://r-nimble.org/" target="_blank">NIMBLE</a> to build the model and corresponding MCMC algorithm.

\   

```{r, eval=FALSE}
library(nimble)

code <- nimbleCode({
    ## priors:
    for(i in 1:11) {
        b[i] ~ dnorm(0, sd=10000)
    }
    p_obs_plant ~ dbeta(1, 1)   ## probability of xf detection in source plant
    p_obs_vector ~ dbeta(1, 1)  ## probability of xf detection in vector
    p_trans_plant_dsf ~ dbeta(1, 1)    ## probabilities of *any* xf transmission to plant measurement site
    p_trans_plant_wt  ~ dbeta(1, 1)    ##
    p_trans_vector_dsf ~ dbeta(1, 1)    ## probabilities of *any* xf transmission to vector
    p_trans_vector_wt  ~ dbeta(1, 1)    ##
    ## biological model:
    for(i in 1:N) {
        ## transmission of xf to plant site:
        z_trans_plant[i] ~ dbern(p_trans_plant_dsf*genotype_dsf[i] + p_trans_plant_wt*genotype_wt[i])
        lambda_plant[i] <- z_trans_plant[i] * exp(b[1]*genotype_dsf[i] + b[2]*genotype_wt[i] + b[3]*distance[i]*genotype_dsf[i] + b[4]*distance[i]*genotype_wt[i])
        ## transmission of xf to vector:
        z_trans_vector[i] ~ dbern(p_trans_vector_dsf*genotype_dsf[i] + p_trans_vector_wt*genotype_wt[i])
        lambda_vector[i] <- z_trans_vector[i] * (b[5]*genotype_dsf[i] + b[6]*genotype_wt[i] + b[7]*lambda_plant[i]*genotype_dsf[i] + b[8]*lambda_plant[i]*genotype_wt[i])
    }
    ## only model observed (non-NA) values of xf_source_plant:
    for(iObs in 1:N_obs_plant) {
        z_obs_plant[obs_ind_plant[iObs]] ~ dbern(p_obs_plant)
        xf_source_plant[obs_ind_plant[iObs]] ~ dpois(z_obs_plant[obs_ind_plant[iObs]] * lambda_plant[obs_ind_plant[iObs]])
    }
    ## only model observed (non-NA) values of xf_vector:
    for(iObs in 1:N_obs_vector) {
        z_obs_vector[obs_ind_vector[iObs]] ~ dbern(p_obs_vector)
        xf_vector[obs_ind_vector[iObs]] ~ dpois(z_obs_vector[obs_ind_vector[iObs]] * lambda_vector[obs_ind_vector[iObs]])
    }
    ## only model observed (non-NA) values of infected:
    for(iObs in 1:N_obs_infected) {
        logit(p_infect[obs_ind_infected[iObs]]) <- b[9]*genotype_dsf[obs_ind_infected[iObs]] + b[10]*genotype_wt[obs_ind_infected[iObs]] + b[11]*lambda_vector[obs_ind_infected[iObs]]
        infected[obs_ind_infected[iObs]] ~ dbern(p_infect[obs_ind_infected[iObs]])
    }
    ## genotype DSF predictive nodes:
    lambda_plant_dsf <- p_trans_plant_dsf * exp(b[1])
    lambda_vector_dsf <- p_trans_vector_dsf * (b[5] + b[7]*lambda_plant_dsf)
    logit(p_infect_dsf) <- b[9] + b[11]*lambda_vector_dsf
    ## genotype WT predictive nodes:
    lambda_plant_wt <- p_trans_plant_wt * exp(b[2])
    lambda_vector_wt <- p_trans_vector_wt * (b[6] + b[8]*lambda_plant_wt)
    logit(p_infect_wt) <- b[10] + b[11]*lambda_vector_wt
    ## xf_source_plant and xf_vector predictions
    for(i in 1:N) {
        pred_lambda_plant[i] <- exp(b[1]*genotype_dsf[i] + b[2]*genotype_wt[i] + b[3]*distance[i]*genotype_dsf[i] + b[4]*distance[i]*genotype_wt[i])
        pred_lambda_vector[i] <- b[5]*genotype_dsf[i] + b[6]*genotype_wt[i] + b[7]*pred_lambda_plant[i]*genotype_dsf[i] + b[8]*pred_lambda_plant[i]*genotype_wt[i]
        pred_xf_source_plant[i] ~ dpois(pred_lambda_plant[i])
        pred_xf_vector[i] ~ dpois(pred_lambda_vector[i])
    }
})

inits <- list(
    b = c(rep(0,4), 1, 1, 0, 0, rep(0,3)),
    p_trans_plant_dsf = 0.5,
    p_trans_plant_wt = 0.5,
    p_trans_vector_dsf = 0.5,
    p_trans_vector_wt = 0.5,
    p_obs_plant = 0.5,
    p_obs_vector = 0.5,
    z_trans_plant = rep(1, constants$N),
    z_trans_vector = rep(1, constants$N),
    z_obs_plant = rep(1, constants$N),
    z_obs_vector = rep(1, constants$N),
    pred_xf_source_plant = rep(1, constants$N),
    pred_xf_vector = rep(1, constants$N)
)

Rmodel <- nimbleModel(code, constants, data, inits)

calculate(Rmodel)    ## -23645598236

conf <- configureMCMC(Rmodel)

## add specialized automated factor slice samplers:
conf$addSampler(c('b[5]','b[7]'), 'AF_slice')
conf$addSampler(c('b[6]','b[8]'), 'AF_slice')
conf$addSampler(c('b[9:11]'),     'AF_slice')

## add monitors for predictive nodes:
conf$addMonitors('p_infect_dsf', 'p_infect_wt')

## add monitors for probability of infection (thin = 100)
conf$setThin2(100)
conf$addMonitors2('p_infect')
## also add monitors for predicted xf vector concentrations lambda_vector and predicted xf source plant concentrations lambda_plant (thin = 100)
conf$addMonitors2('lambda_vector', 'lambda_plant')
conf$addMonitors2('p_infect', 'pred_xf_source_plant', 'pred_xf_vector')

Rmcmc <- buildMCMC(conf)

system.time(Cmodel <- compileNimble(Rmodel))
```

```
compiling... this may take a minute. Use 'showCompilerOutput = TRUE' to see C++ compiler details.
compilation finished.
   user  system elapsed 
 13.564   0.580  14.362 
```

```{r, eval=FALSE}
system.time(Cmcmc <- compileNimble(Rmcmc, project = Rmodel))
```

```
compiling... this may take a minute. Use 'showCompilerOutput = TRUE' to see C++ compiler details.
compilation finished.
   user  system elapsed 
 19.140   0.437  19.723 
```

```{r, eval=FALSE}
niter <-  120000
nburnin <- 10000
set.seed(0)
system.time(samples <- runMCMC(Cmcmc, niter, nburnin=nburnin, nchains=2, returnCodaMCMC=TRUE))
samples2 <- as.matrix(Cmcmc$mvSamples2)
```

```
running chain 1...
|-------------|-------------|-------------|-------------|
|-------------------------------------------------------|
running chain 2...
|-------------|-------------|-------------|-------------|
|-------------------------------------------------------|
   user  system elapsed 
140.818   0.379 141.561 
```

```{r, include=FALSE, eval=FALSE}
save(samples, samples2, file='results/samples5.RData')
```

```{r, include=FALSE}
setwd('~/github/zeilinger_grapevine/')
load('data/temp5.RData')
load('results/samples5.RData')
```

\   

### Convergence 

We assess convergence of two chains, each with 100,000 post burn-in samples.

\   

The Brooks-Gelman-Rubin diagnostic over two chains of indicates convergence.

```{r, warning=FALSE}
library(coda)
```

```{r }
gelman.diag(samples)
```

\  

Compare parameter estimates across the two chains, to visually
make sure they agree:

```{r }
chainsPlot(samples, nrows = 2, buffer.right = 1)
```

\   

The effective sample size of the first chain is satisfactory, with a
minimum of more than 1,000 effectively independent samples from all posterior
dimensions, resulting from the 100,000 post burn-in samples.

```{r eval = FALSE}
round(cbind(
    length = apply(samples[[1]], 2, length),
    ESS    = effectiveSize(samples[[1]])
))
```

```
                   length    ESS
b[1]                1e+05  18736
b[2]                1e+05  22825
b[3]                1e+05  18070
b[4]                1e+05  23375
b[5]                1e+05  98917
b[6]                1e+05 100000
b[7]                1e+05 100000
b[8]                1e+05 100000
b[9]                1e+05   3389
b[10]               1e+05   4125
b[11]               1e+05   5766
p_infect_dsf        1e+05  12218
p_infect_wt         1e+05  46633
p_obs_plant         1e+05   6337
p_obs_vector        1e+05   1049
p_trans_plant_dsf   1e+05   5533
p_trans_plant_wt    1e+05   6714
p_trans_vector_dsf  1e+05   1207
p_trans_vector_wt   1e+05   1873
```

\   

### Posterior Mean, Median, and 95% Credible Intervals 

\   

```{r}
res <- round(cbind(
    `CI Lower` = apply(samples[[1]], 2, function(x) quantile(x, 0.025)),
    `Mean`         = apply(samples[[1]], 2, mean),
    `Median`       = apply(samples[[1]], 2, median),
    `CI Upper` = apply(samples[[1]], 2, function(x) quantile(x, 0.975))
), 5)

res
```

\   

### Interpretations (updated v5)

\   

##### Bacteria concentration in source plants (constant terms)

\   

$\beta_1$, the constant term in the log() predictor for 
source plant xf concentration in genotype DSF plants, is
essentially `r round(res["b[1]","Mean"],3)`. Thus, the baseline xf
concentration (at distance=0) in genotype DFS plants is $e^{\beta_1}
\approx$ 44,000,000.

$\beta_2$, the constant term in the log() predictor for 
source plant xf concentration in genotype WT plants, is essentially `r round(res["b[2]","Mean"],3)`,
slightly *higher* than the genotype DSF constant term.  Thus, the baseline xf
concentration (at distance=0) in genotype WT plants is $e^{\beta_2}
\approx$ 62,000,000.

These values of $\beta_1$ and $\beta_2$ imply that
for the *same distance*, genotype WT plants will have more xf
bacteria than genotype DSF plants.  Specifically, higher in the WT
plants by
a factor of $e^{\beta_2-\beta_1} = e^{0.346}=$
`r round(exp(res["b[2]","Mean"] - res["b[1]","Mean"]), 3)`.

\   

##### Bacteria concentration in source plants (distance effect)

\   

$\beta_3$, the coefficient of distance in the log() predictor for 
source plant xf concentration in genotype DSF plants, is essentially
`r round(res["b[3]","Mean"],3)`. For every additional unit of
distance, the source plant xf concentration in DSF plants will decrease by a factor
of $e^{\beta_3}=$ `r round(exp(res["b[3]","Mean"]), 3)`.

$\beta_4$, the coefficient of distance in the log() predictor for 
vector xf concentration in genotype WT plants, is essentially
`r round(res["b[4]","Mean"],3)`.  This is significantly lower than that
of genotype DSF plants, implying that the xf concentration decreases
 more rapidly (as a function of distance) in genotype WT plants, as
compared to genotype DSF plants.  Specicially, for every additional unit of
distance, the source plant xf concentration in WT plants will decrease by a factor
of $e^{\beta_4}=$ `r round(exp(res["b[4]","Mean"]), 3)`.

\  


##### Bacteria presence or absense in source plant: true negative detections (new v5)

\   

We allow some probability that there is 0 bacteria present at the 
source plant test site, regardless of distance.  This probability is 
allowed to vary between DSF and WT source plant genotypes. 

For DSF source plants, the probability of bacteria being present is 
estimated as `r round(res["p_trans_plant_dsf","Mean"],3)`, with 95% 
credible interval (`r round(res["p_trans_plant_dsf","CI Lower"],3)`,
`r round(res["p_trans_plant_dsf","CI Upper"],3)`). 

For WT source plants, the probability of bacteria being present is 
estimated as `r round(res["p_trans_plant_wt","Mean"],3)`, with 95% 
credible interval (`r round(res["p_trans_plant_wt","CI Lower"],3)`,
`r round(res["p_trans_plant_wt","CI Upper"],3)`). 

This means that on average, there was a 47% chance of any bacteria
being present at the test site in DSF plants, and a 65% chance of any
bacteria being present at the test site in WT plants.

\   

##### Bacteria transmission from source plants to vectors (vector concentration effect)

\   

For DSF source plants, $\beta_5$ and $\beta_7$ determine the linear
relationship for how xf is transmitted to vectors, as
$\lambda_{vector} = \beta_5 + \beta_7 \cdot \lambda_{source\ plant}$.  We are
interested in the $\beta_7$ coefficient, which is approximately equal to 0.00037.  This means that for DSF source
plants, the vector xf concentration increases at a rate of 0.00037 times the source plant xf concentration.

For WT source plants, $\beta_6$ and $\beta_8$ determine the linear
relationship for how xf is transmitted to vectors, as
$\lambda_{vector} = \beta_6 + \beta_8 \cdot \lambda_{source\ plant}$.  We are
interested in the $\beta_8$ coefficient, which is approximately equal to 0.00024.  This means that for WT source
plants, the vector xf concentration increases at a rate of 0.00024 times the
source plant xf concentration.  This is a much *lower transmission
rate* from (source plants to vectors) for WT plants, as compared to DSF
plants.

\   

##### Bacteria transmission from source plants to vectors: true negative detections (new v5)

\   

We allow some probability that  0 bacteria is transmitted to the
vector, regardless of the bacteria concentration in the source plant.
This probability is allowed to vary between DSF and WT source plant genotypes. 

For DSF source plants, the probability of bacteria being transmitted
to the vector is estimated as `r round(res["p_trans_vector_dsf","Mean"],3)`, with 95%
credible interval (`r round(res["p_trans_vector_dsf","CI Lower"],3)`,
`r round(res["p_trans_vector_dsf","CI Upper"],3)`).  
 
For WT source plants, the probability of bacteria being transmitted 
to the vector is estimated as `r round(res["p_trans_vector_wt","Mean"],3)`, with 95%
credible interval (`r round(res["p_trans_vector_wt","CI Lower"],3)`,
`r round(res["p_trans_vector_wt","CI Upper"],3)`).  

The probability of transmission of bacteria to the vectors was
extremely similar between DSF and WT plants.  Given there was bacteria
present at the source plant test site, then there is a 50% chance of
transmission to the vector from DSF source plants, and a 56% chance of
transmission from WT source plants.  These estimates were not
statistically significantly different.

\   

##### Probability of test plant infection (genotype effect) 

\   

$\beta_{9}$ gives the baseline probability of infection (on the logit
scale) for genotype DSF plants.  The 95% CI for $\beta_{9}$ is
(`r round(res["b[9]","CI Lower"], 2)`,
`r round(res["b[9]","CI Upper"], 2)`).  Taking the inverse-logit
transformation $\left( \tfrac{1}{1+e^{-x}} \right)$, this gives a 95% CI for the baseline probability of infection for DSF
source plants as (`r round(1/(1+exp(-res["b[9]","CI Lower"])), 2)`,
`r round(1/(1+exp(-res["b[9]","CI Upper"])), 2)`).  This
does not take xf concentration in the vector into account.

$\beta_{10}$ gives the baseline probability of infection (on the logit
scale) for genotype WT plants.  The 95% CI for $\beta_{10}$ is
(`r round(res["b[10]","CI Lower"], 2)`,
`r round(res["b[10]","CI Upper"], 2)`).  Taking the inverse-logit
transformation $\left( \tfrac{1}{1+e^{-x}} \right)$, this gives a 95% CI for the baseline probability of infection for WT
source plants as (`r round(1/(1+exp(-res["b[10]","CI Lower"])), 2)`,
`r round(1/(1+exp(-res["b[10]","CI Upper"])), 2)`).  This
does not take xf concentration in the vector into account.

\   

##### Probability of test plant infection (vector xf effect) (significant change v5)

\   

$\beta_{11}$ is the coefficient for vector xf level in the logit() predictor for test plant
infection.  That is, this (on the logit scale) determines how vector
xf concentration affects the probability of test plant infection.

This is noteworthy because in the previous Analysis 4, this term was
not signficantly different from 0.  But now, with the new
probabilistic models of zero transmissions, this term has a median
value of 0.00019, with 95% credible interval of (0.00006, 0.00037).

This means that increased vector xf concentration does have a
significant positive effect on the probability of test plant
infection.  It's difficult to exactly quantify how much the
probability of infection will increase as the vector xf concentration
increases, since this coefficient is on the logit scale.

However, given that the observed (non-zero) vector xf concentrations are
roughly between 1,000 and 60,000, this implies an increase (on the
logit scale) of between (1000)(0.00019) = 0.19 and (60000)(0.00019)
= 11.4.  An increase of 0.19 (on the logit scale) implies a
noteworthy, although not massive increase in the probability of
infection; the increase of 11.4 (on the logit scale) is large enough
to ensure a probability of infection essentially equal to 1.

\   

##### Bacteria detection (source plants, vectors) 

\   

$p_{obs.\ source\ plant}$, the probability of xf detection in source
plants, is bounded by the 95% CI (`r round(res["p_obs_plant","CI Lower"], 2)`,
`r round(res["p_obs_plant","CI Upper"], 2)`), with median
`r round(res["p_obs_plant","Median"], 3)`.  This means the test used has about
an 83% chance of detecting any xf bacteria in source plants.

\   

$p_{obs.\ vector}$, the probability of xf detection in vectors,
is bounded by the 95% CI (`r round(res["p_obs_vector","CI Lower"], 2)`,
`r round(res["p_obs_vector","CI Upper"], 2)`) , with median
`r round(res["p_obs_vector","Median"], 3)`.  This means the test used has about
a 37% chance of detecting any xf bacteria in vectors.

\   

##### Predictive distributions for test plant infection 

\   

The predictive nodes give the best idea of the probability of
infection, from either DSF or WT source plants, predicted at distance = 0.
These estimates take all model parameters and biological processes into account.

- Probability of infection for genotype DSF (at distance = 0) is in the 95% CI: (`r round(res["p_infect_dsf","CI Lower"], 2)`,
`r round(res["p_infect_dsf","CI Upper"], 2)`), with median = `r round(res["p_infect_dsf","Median"], 2)`. 
- Probability of infection for genotype WT (at distance = 0) is in the 95% CI: (`r round(res["p_infect_wt","CI Lower"], 2)`,
`r round(res["p_infect_wt","CI Upper"], 2)`), with median = `r round(res["p_infect_wt","Median"], 2)`. 

\   

Next, we look at the probabilities of infection from *all test plants*,
separated by genotype.  These do not assume any particular distance
(*e.g.*, distance = 0).  Instead, these quite literally represent *all*
distances in the input data set.

\   

```{r }
dsf_ind <- intersect(which(constants$genotype_dsf == 1), constants$obs_ind_infected)
wt_ind  <- intersect(which(constants$genotype_wt  == 1), constants$obs_ind_infected)
pinfect_dsf_nodes <- paste0('p_infect[', dsf_ind, ']')
pinfect_wt_nodes  <- paste0('p_infect[', wt_ind,  ']')
pinfect_dsf <- as.numeric(samples2[, pinfect_dsf_nodes])
pinfect_wt  <- as.numeric(samples2[, pinfect_wt_nodes])
dsf_res <- c(quantile(pinfect_dsf,0.025), mean(pinfect_dsf), median(pinfect_dsf), quantile(pinfect_dsf,0.975))
wt_res <-  c(quantile(pinfect_wt, 0.025), mean(pinfect_wt ), median(pinfect_wt ), quantile(pinfect_wt, 0.975))
infection_results <- rbind(dsf_res, wt_res)
rownames(infection_results) <- c('p_infect_dsf', 'p_infect_wt')
colnames(infection_results) <- c("CI Lower", "Mean", "Median", "CI Upper")
round(infection_results, 2)


#### Plot of parameter estimates and 95% CI
library(ggplot2); library(dplyr); library(tidyr); library(cowplot)
# Add full estimate of p_infect to the results table
row.names(infection_results) <- c("p_infect_dsf_full", "p_infect_wt_full")
plotres <- rbind(res, infection_results) %>% as.data.frame()
names(plotres) <- c("cilower", "mean", "median", "ciupper")
plotres$pars <- row.names(plotres)

# Covariate names for figure
plotres$covarNames <- c("xf population in DSF", "xf population in WT", # b1, b2
                    "effect of distance DSF", "effect of distance WT", # b3, b4
                    "intercept source xf on vector xf DSF", "intercept source xf on vector xf WT", # b5, b6
                    "effect of source xf on vector xf DSF", "effect of source xf on vector xf WT", # b7, b8
                    "baseline P(transmission) DSF", "baseline P(transmission) WT", # b9, 910
                    "effect of vector xf on P(transmission)", # b11
                    "P(transmission) from inoculation point DSF", "P(transmission) from inoculation point WT",
                    "P(detection) source plant", "P(detection) vector",
                    "P(infection) source plant DSF", "P(infection) source plant WT",
                    "P(infection) vector DSF", "P(infection) vector WT",
                    "P(transmission) all distances DSF", "P(transmission) all distances WT")

#### Plotting results
# Plot coefficient estimates and probabilities separately -- on slightly different scales
# Coefficient estimates
plotres1 <- plotres %>% dplyr::filter(pars == "b[1]" | pars == "b[2]" | pars == "b[3]" | pars == "b[4]" | 
                                        pars == "b[7]" | pars == "b[8]" | pars == "b[11]")

coef_plot <- ggplot(plotres1, aes(y = covarNames, x = median)) +
  geom_errorbarh(aes(xmin = cilower, xmax = ciupper), colour = "black", height = 0.2) +
  geom_point(size = 3) +
  geom_vline(linetype = "longdash", xintercept = 0) +
  xlab("Coefficient estimate") + ylab("") + 
  theme_bw() + 
  theme(axis.line = element_line(colour = "black"),
        text = element_text(size = 20),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(colour = "black"),
        panel.background = element_blank()) 
coef_plot

ggsave(filename = "results/coefficient_plot.tiff", 
       plot = coef_plot,
       width = 10, height = 7, units = "in")

# Probability estimates
# plotres2 <- plotres %>% 
#   dplyr::filter(pars == "p_infect_dsf" | pars == "p_infect_wt" | pars == "p_obs_plant" | pars == "p_obs_vector" |
#                   pars == "p_infect_full_dsf" | pars == "p_infect_full_wt")

plotres2 <- plotres %>% dplyr::filter(grepl("p_", pars))

coef_plot2 <- ggplot(plotres2, aes(y = covarNames, x = median)) +
  geom_errorbarh(aes(xmin = cilower, xmax = ciupper), colour = "black", height = 0.2) +
  geom_point(size = 3) +
  #geom_vline(linetype = "longdash", xintercept = 0) +
  xlab("Probability estimate") + ylab("") + 
  xlim(c(0,1)) +
  theme_bw() + 
  theme(axis.line = element_line(colour = "black"),
        text = element_text(size = 20),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(colour = "black"),
        panel.background = element_blank()) 
coef_plot2

ggsave(filename = "results/probability_estimate_plot.tiff", 
       plot = coef_plot2,
       width = 10, height = 7, units = "in")

```

\   

We see that:

- Probabilities of infection for genotype DSF plants are in the 95% CI:
(`r round(infection_results["p_infect_dsf","CI Lower"], 2)`,
`r round(infection_results["p_infect_dsf","CI Upper"], 2)`), with
median = `r round(infection_results["p_infect_dsf","Median"], 2)`.
- Probabilities of infection for genotype WT plants are in the 95% CI:
(`r round(infection_results["p_infect_wt","CI Lower"], 2)`,
`r round(infection_results["p_infect_wt","CI Upper"], 2)`), with
median = `r round(infection_results["p_infect_wt","Median"], 2)`.

\  

This is not so surprising.  It says that for each genotype, when we consider **all** plant,
vector, and distance combinations, there's huge variation (nearly
spanning the interval [0, 1]) in the probability of test plant infection.

\   

These agree well with the predictions at distance = 0, although the
95% intervals here are wider, since this is representative of all possible
distances (giving larger variation in the probability of infection).
The medians are similar, although the median probability of test plant
infection is 15% for DSF source plants, and 35% for WT source plants.

\   

### Hierarchical Plots (updated v5)

\    

Predicted probability of infection versus observed xf concentration
in vectors (log base 10), separated by genotype.  We include best-fit
regression lines.

This plot has been updated since adding the new probabilistic models
for zero xf transmissions, in the source plant and the vectors.  The
plot below shows how the probability of infection varies as a function
of xf concentration in the vectors, for each plant genotype.

\   

```{r }
## indices of DSF and WT cases for which xf_vector was observed
dsf_ind <- intersect(which(constants$genotype_dsf == 1), constants$obs_ind_vector)
wt_ind  <- intersect(which(constants$genotype_wt  == 1), constants$obs_ind_vector)
## get xf_vector values for each genotype, and take log base 10
xf_vector_dsf_log10 <- log10(data$xf_vector[dsf_ind])
xf_vector_wt_log10  <- log10(data$xf_vector[wt_ind])
## change -infinity to 0
xf_vector_dsf_log10[xf_vector_dsf_log10 < 0] <- 0
xf_vector_wt_log10 [xf_vector_wt_log10  < 0] <- 0
## get samples of p_infect for each genotype, and take the median
p_infect_dsf_nodes <- paste0('p_infect[', dsf_ind, ']')
p_infect_wt_nodes  <- paste0('p_infect[', wt_ind,  ']')
p_infect_dsf <- apply(samples2[, p_infect_dsf_nodes], 2, median, na.rm = TRUE)
p_infect_wt  <- apply(samples2[, p_infect_wt_nodes],  2, median, na.rm = TRUE)
## plot p_infect vs. xf_vector (for each genotype) + regression lines
plot(xf_vector_dsf_log10, p_infect_dsf, ylim = c(0, 1), xlab = 'log10(xf_vector)', ylab = 'Pr(infect)', pch = 2)
abline(lm(p_infect_dsf ~ xf_vector_dsf_log10), lty = 2)
points(xf_vector_wt_log10, p_infect_wt, pch = 1)
abline(lm(p_infect_wt ~ xf_vector_wt_log10), lty = 1)
legend('topleft', legend = c('DSF', 'WT'), lty = 2:1)
legend('top',      legend = c('DSF', 'WT'), pch = 2:1)


#### Create data set of predicted results and plot in ggplot
# Make a WT data.frame and a DSF data.frame
dsfdf <- data.frame(xf_vector_log10 = xf_vector_dsf_log10,
                    p_infect = p_infect_dsf,
                    genotype = "DSF")
wtdf <- data.frame(xf_vector_log10 = xf_vector_wt_log10,
                   p_infect = p_infect_wt,
                   genotype = "WT")
plotdf <- rbind(dsfdf, wtdf)


vectorTransPlot <- ggplot(data = plotdf) +
  geom_point(data = plotdf[plotdf$genotype == "WT",], aes(y = p_infect, x = xf_vector_log10), size = 4, pch = 16) +
  geom_point(data = plotdf[plotdf$genotype == "DSF",], aes(y = p_infect, x = xf_vector_log10), size = 4, pch = 1) +
  stat_smooth(data = plotdf[plotdf$genotype == "WT",], aes(y = p_infect, x = xf_vector_log10), method = "lm", se = FALSE, col = "black", lty = 1) +
  stat_smooth(data = plotdf[plotdf$genotype == "DSF",], aes(y = p_infect, x = xf_vector_log10), method = "lm", se = FALSE, col = "black", lty = 2) +
  xlab("Xylella populations in vectors (CFU, log10)") + ylab("Probability of transmission") + ylim(0,1) +
  theme_bw() + 
  theme(axis.line = element_line(colour = "black"),
        axis.text = element_text(size=14),
        axis.title = element_text(size=16),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(colour = "black"),
        panel.background = element_blank()) 
vectorTransPlot

ggsave(filename = "results/transmission_vectorxf_plot.tiff",
       plot = vectorTransPlot,
       width = 7, height = 7, units = "in")
  


#### Plotting probability of transmission vs source plant populations
#### Plot of transmission vs. xf in source plant, using original xf_source data
plotdf$xf_source_log10 <- log10(c(data$xf_source_plant[dsf_ind], data$xf_source_plant[wt_ind]))
## change -infinity to 0
plotdf$xf_source_log10[plotdf$xf_source_log10 < 0] <- 0

## plot p_infect vs. xf_source (for each genotype) + regression lines
tiff("results/transmission_sourcexf_plot.tif")
  plot(xf_source_dsf_log10, p_infect_dsf, ylim = c(0, 1), 
       xlab = 'Xylella population in source plants (log10 transformed)', 
       ylab = 'P(transmission)', pch = 2)
  abline(lm(p_infect_dsf ~ xf_source_dsf_log10), lty = 2)
  points(xf_source_wt_log10, p_infect_wt, pch = 1)
  abline(lm(p_infect_wt ~ xf_vector_wt_log10), lty = 1)
  legend('topright', legend = c('DSF', 'WT'), lty = 2:1)
  legend('top',      legend = c('DSF', 'WT'), pch = 2:1)
dev.off()


## p_infect vs. xf_source in ggplot
sourceTransPlot <- ggplot(data = plotdf) +
  geom_point(data = plotdf[plotdf$genotype == "WT",], aes(y = p_infect, x = xf_source_log10), size = 4, pch = 16) +
  geom_point(data = plotdf[plotdf$genotype == "DSF",], aes(y = p_infect, x = xf_source_log10), size = 4, pch = 1) +
  stat_smooth(data = plotdf[plotdf$genotype == "WT",], aes(y = p_infect, x = xf_source_log10), method = "lm", se = FALSE, col = "black", lty = 1) +
  stat_smooth(data = plotdf[plotdf$genotype == "DSF",], aes(y = p_infect, x = xf_source_log10), method = "lm", se = FALSE, col = "black", lty = 2) +
  xlab("Xylella populations in source plants (CFU/g, log10)") + ylab("Probability of transmission") + ylim(0,1) +
  theme_bw() + 
  theme(axis.line = element_line(colour = "black"),
        axis.text = element_text(size=14),
        axis.title = element_text(size=16),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(colour = "black"),
        panel.background = element_blank()) 
sourceTransPlot

ggsave(filename = "results/transmission_sourcexf_plot.tiff",
       plot = sourceTransPlot,
       width = 7, height = 7, units = "in")


#### Plotting xf_vector vs. xf_source

## Extract estimates of lambda_plant
# lambda_plant_dsf_nodes <- paste0('lambda_plant[', dsf_ind, ']')
# lambda_plant_wt_nodes <- paste0('lambda_plant[', wt_ind, ']')
# lambda_plant_dsf <- apply(samples2[, lambda_plant_dsf_nodes], 2, median, na.rm = TRUE)
# lambda_plant_wt <- apply(samples2[, lambda_plant_wt_nodes], 2, median, na.rm = TRUE)
# # Log10 transform data and add to plot data.frame
# plotdf$lambda_plant_log10 <- log10(c(lambda_plant_dsf, lambda_plant_wt))
# ## change -infinity to 0
# plotdf$lambda_plant_log10[plotdf$lambda_plant_log10 < 0] <- 0
# 
# plot(plotdf$xf_source_log10, plotdf$lambda_plant_log10)
# # One point is 0 in raw data but lambda > 0: node 32. Why is this?
# 
# ## Extract estimates of lambda_vector
# lambda_vector_dsf_nodes <- paste0('lambda_vector[', dsf_ind, ']')
# lambda_vector_wt_nodes <- paste0('lambda_vector[', wt_ind, ']')
# lambda_vector_dsf <- apply(samples2[, lambda_vector_dsf_nodes], 2, median, na.rm = TRUE)
# lambda_vector_wt <- apply(samples2[, lambda_vector_wt_nodes], 2, median, na.rm = TRUE)
# # Log10 transform data and add to plot data.frame
# plotdf$lambda_vector_log10 <- log10(c(lambda_vector_dsf, lambda_vector_wt))
# ## change -infinity to 0
# plotdf$lambda_vector_log10[plotdf$lambda_vector_log10 < 0] <- 0
# 
# ## Looking at lambdas
# with(plotdf[plotdf$genotype == "DSF",], plot(x = jitter(lambda_plant_log10, amount = 0), y = jitter(lambda_vector_log10, amount = 0)))
# with(plotdf[plotdf$genotype == "WT",], plot(x = jitter(lambda_plant_log10, amount = 0), y = jitter(lambda_vector_log10, amount = 0)))
# 
# 
# ## Generate predictions from b[] coefficients
# # Extract coefficients
# b5 <- plotres[plotres$pars == "b[5]", "median"] # Intercept for DSF
# b6 <- plotres[plotres$pars == "b[6]", "median"] # Intercept for WT
# b7 <- plotres[plotres$pars == "b[7]", "median"] # Slope for DSF
# b8 <- plotres[plotres$pars == "b[8]", "median"] # Slope for WT
# # Calculate predicted xf pops in vectors
# xplant <- with(plotdf[!is.na(plotdf$xf_source_log10),], runif(100, min = min(xf_source_log10), max = max(xf_source_log10))) %>% sort()
# vectorPred_dsf <- log10(b5 + b7*xplant)
# vectorPred_wt <- log10(b6 + b8*xplant)
# # Combine into data.frame
# plotPred <- data.frame(cbind(xplant, vectorPred_dsf, vectorPred_wt))
# 
# # Note: Linear models are only modeling non-zero values, remove zeros from raw data
# 
# ## ggplot
# sourceVectorPlot <- ggplot(data = plotdf) +
#   geom_point(data = plotdf[plotdf$genotype == "WT" & plotdf$xf_vector_log10 > 0,], 
#              aes(y = jitter(xf_vector_log10, amount = 0.05), x = jitter(xf_source_log10, amount = 0.05)),
#              size = 4, pch = 1) +
#   geom_point(data = plotdf[plotdf$genotype == "DSF" & plotdf$xf_vector_log10 > 0,], 
#              aes(y = jitter(xf_vector_log10, amount = 0.05), x = jitter(xf_source_log10, amount = 0.05)),
#              size = 4, pch = 2) +
#   # stat_smooth(data = plotdf[plotdf$genotype == "WT",], aes(y = lambda_vector_log10, x = lambda_plant_log10), 
#   #             method = "lm", se = FALSE, col = "black", lty = 1) +
#   # stat_smooth(data = plotdf[plotdf$genotype == "DSF",], aes(y = lambda_vector_log10, x = lambda_plant_log10), 
#   #             method = "lm", se = FALSE, col = "black", lty = 2) +
#   stat_smooth(data = plotPred, aes(y = vectorPred_wt, x = xplant), method = "lm", se = FALSE, col = "black", lty = 1) +
#   stat_smooth(data = plotPred, aes(y = vectorPred_dsf, x = xplant), method = "lm", se = FALSE, col = "black", lty = 2) +
#   xlab("Xylella populations in source plants (CFU/g, log10)") + ylab("Xylella populations in vectors (CFU, log10)") + #ylim(0,1) +
#   theme_bw() + 
#   theme(axis.line = element_line(colour = "black"),
#         axis.text = element_text(size=14),
#         axis.title = element_text(size=16),
#         panel.grid.major = element_blank(),
#         panel.grid.minor = element_blank(),
#         panel.border = element_rect(colour = "black"),
#         panel.background = element_blank()) 
# sourceVectorPlot
# 
# ggsave(filename = "results/vectorxf_sourcexf_plot.tiff",
#        plot = sourceVectorPlot,
#        width = 7, height = 7, units = "in")


# #### Plotting distance vs. lambda_plant
# # Need to get the un-scaled (raw) distance from the original data file
# distance_dsf <- dsf$dsfData$raw_distance[dsf_ind]
# distance_wt <- dsf$dsfData$raw_distance[wt_ind]
# plotdf$distance <- c(distance_dsf, distance_wt)
# 
# # Extract coefficients
# b1 <- plotres[plotres$pars == "b[1]", "median"] # Intercept for DSF
# b2 <- plotres[plotres$pars == "b[2]", "median"] # Intercept for WT
# b3 <- plotres[plotres$pars == "b[3]", "median"] # Slope for DSF
# b4 <- plotres[plotres$pars == "b[4]", "median"] # Slope for WT
# 
# xdistance <- with(plotdf[!is.na(plotdf$distance),], runif(100, min = min(distance), max = max(distance))) %>% sort()
# plantPred_dsf <- log10(exp(b1) + exp(b3)*xdistance)
# plantPred_wt <- log10(exp(b2) + exp(b4)*xdistance)
# 
# plotPred2 <- data.frame(cbind(xdistance, plantPred_dsf, plantPred_wt))
# 
# # Note: Linear models are only modeling non-zero values, remove zeros from raw data
# 
# distanceSourcePlot <- ggplot(data = plotdf) +
#   geom_point(data = plotdf[plotdf$genotype == "WT" & plotdf$xf_source_log10 > 0,], 
#              aes(y = xf_source_log10, x = distance), size = 4, pch = 1) +
#   geom_point(data = plotdf[plotdf$genotype == "DSF" & plotdf$xf_source_log10 > 0,], 
#              aes(y = xf_source_log10, x = distance), size = 4, pch = 2) +
#   # stat_smooth(data = plotdf[plotdf$genotype == "WT",], aes(y = lambda_plant_log10, x = distance), 
#   #             method = "lm", se = FALSE, col = "black", lty = 1) +
#   # stat_smooth(data = plotdf[plotdf$genotype == "DSF",], aes(y = lambda_plant_log10, x = distance), 
#   #             method = "lm", se = FALSE, col = "black", lty = 2) +
#   stat_smooth(data = plotPred2, aes(y = plantPred_wt, x = xdistance), method = "lm", se = FALSE, col = "black", lty = 1) +
#   stat_smooth(data = plotPred2, aes(y = plantPred_dsf, x = xdistance), method = "lm", se = FALSE, col = "black", lty = 2) +
#   ylab("Xylella populations in source plants (CFU/g, log10)") + xlab("Distance from inoculation point (cm)") + #ylim(0,1) +
#   theme_bw() + 
#   theme(axis.line = element_line(colour = "black"),
#         axis.text = element_text(size=14),
#         axis.title = element_text(size=16),
#         panel.grid.major = element_blank(),
#         panel.grid.minor = element_blank(),
#         panel.border = element_rect(colour = "black"),
#         panel.background = element_blank()) 
# distanceSourcePlot
# 
# ggsave(filename = "results/sourcexf_distance_plot.tiff",
#        plot = distanceSourcePlot,
#        width = 7, height = 7, units = "in")


```

\    



### Posterior Density Plots (updated v5)

\   
 
##### Predictive distributions for test plant infection (significantly updated v5) 

\   

Below are the posterior predictive distributions for test plant 
infection, for genotype DSF and WT plants, predicted at distance = 0. 

\   

```{r fig.height=2}
samplesPlot(samples[[1]], c('p_infect_dsf','p_infect_wt'), width = 4, height = 2, traceplot = FALSE)
```

\   

Below are the posterior predictive distributions for test plant 
infection, for genotype DSF and WT plants, for all distances.

These have changed greatly, since the addition of allowing
zero-transmissions of xf bacteria from source plants, and also to
vectors.  These zero-transmission cases give rise to the bimodal
distributions seen below, for probability of infection.  The large
modes near probability of infection = 0 represent those cases where
there was zero transmission of bacteria either at the source plant, or
to the vector, and hence the probability of infection is also zero.

The much larger mass near to probability of infection = 0 for the
DSF genotype is explained by the results we've seen above.  For DSF
plants there was only a 47% chance of any bacteria being present at
the source plant test site (versus 65% chance for WT plants; much more
likely to have bacteria).  And more minor, but still pushing the results
in the same direction, the probability of bacteria transmission to the
vectors was 50% for DSF source plants (versus a higher 56% for WT
plants).  Both of these results (from the new probabilistic
transmission models) drive the results below, where there's a large
mode around probability of infection = 0 for DSF plants, and a similar
but much smaller mode for WT source plants.

```{r fig.height=2}
set.seed(0)
pinfect_df <- data.frame(p_infect_dsf = sample(pinfect_dsf,length(pinfect_wt)),
                         p_infect_wt  = pinfect_wt)
samplesPlot(pinfect_df, c('p_infect_dsf','p_infect_wt'), width = 4, height = 2, traceplot = FALSE)
```


\   
 
##### Posterior densities of transmission probabilities (new v5)

First, compare the posterior distributions of presense of xf bacteria 
at source plant test sites, for DSF and WT source plants.

We see a reasonable difference in these probabilities, namely that WT
source plants are more likely to have bacteria present at the test site.

```{r fig.height=2}
samplesPlot(samples[[1]], c('p_trans_plant_dsf', 'p_trans_plant_wt'), width = 4, height = 2, traceplot = FALSE) 
```

\   

Next, compare the posterior distributions of transfer of xf bacteria 
from the source plant to the vectors, for DSF and WT source plants.

We see essentially no difference here between DSF at WT source
plants.  If bacteria are present at the test site, then vectors are
equally likely to acquire the bacteria from either at DSF or a WT
source plant.

```{r fig.height=2}
samplesPlot(samples[[1]], c('p_trans_vector_dsf', 'p_trans_vector_wt'), width = 4, height = 2, traceplot = FALSE) 
```

\  

##### New Predictive plots

\   

```{r }
library(dplyr)

dsf_ind <- constants$genotype_dsf == 1
wt_ind  <- constants$genotype_wt  == 1

pred_xf_source_plant <- samples2[,grep("^pred_xf_source_plant", colnames(samples2))]
pred_xf_vector       <- samples2[,grep("^pred_xf_vector",       colnames(samples2))]

pred_df <- data.frame(
    genotype = ifelse(constants$genotype_dsf, 'DSF', 'WT'),
    distance = dsf$dsfData$raw_distance,
    xf_source_plant = data$xf_source_plant,
    xf_vector = data$xf_vector,
    xf_plant_med = unname(apply(pred_xf_source_plant, 2, median)),
    xf_vector_med = unname(apply(pred_xf_vector, 2, median)),
    xf_source_log10 = log10(data$xf_source_plant),
    xf_vector_log10 = log10(data$xf_vector),
    xf_plant_med_log10  = log10(unname(apply(pred_xf_source_plant, 2, median))),
    xf_vector_med_log10 = log10(unname(apply(pred_xf_vector, 2, median)))
)

# Set -Inf to 0
for(i in grep("_log10", names(pred_df))){
  pred_df[,i] <- ifelse(pred_df[,i] < 0, 0, pred_df[,i])
}


pred_df %>% arrange(distance) -> pred_df
pred_df %>% filter(genotype == 'DSF') -> pred_df_dsf
pred_df %>% filter(genotype == 'WT')  -> pred_df_wt


#### Plot of xf_source_plant vs. distance
plot(-10, -10,
     xlim = range(pred_df$distance),
     ylim = range(pred_df$xf_source_log10, na.rm = TRUE),
     xlab = 'Distance', ylab = 'Predicted Source Plant xf Concentration')
# Use unscaled (raw) distance
points(pred_df_dsf$distance, y = pred_df_dsf$xf_source_log10, col = 'blue', pch = 4)
points(pred_df_wt$distance,  y = pred_df_wt$xf_source_log10,  col = 'red',  pch = 4)
lines(pred_df_dsf$distance, pred_df_dsf$xf_plant_med_log10, col = 'blue')
lines(pred_df_wt$distance,  pred_df_wt$xf_plant_med_log10,  col = 'red')
legend(legend = c('DSF', 'WT'), 'right', col = c('blue', 'red'), lty = 1)


## ggplot
# Plot only data with xf_source_plant > 0
pred_nz <- pred_df %>% filter(xf_source_log10 > 0)

distanceSourcePlot <- ggplot(data = pred_nz) +
  geom_point(data = pred_nz[pred_nz$genotype == "WT",], 
             aes(y = xf_source_log10, x = distance), size = 4, pch = 16) +
  geom_point(data = pred_nz[pred_nz$genotype == "DSF",], 
             aes(y = xf_source_log10, x = distance), size = 4, pch = 1) +
  stat_smooth(data = pred_nz[pred_nz$genotype == "WT",],
              aes(y = xf_plant_med_log10, x = distance), method = "lm", se = FALSE, col = "black", lty = 1) +
  stat_smooth(data = pred_nz[pred_nz$genotype == "DSF",],
              aes(y = xf_plant_med_log10, x = distance), method = "lm", se = FALSE, col = "black", lty = 2) +
  ylab("Xylella populations in source plants (CFU/g, log10)") + xlab("Distance from inoculation point (cm)") + #ylim(0,1) +
  theme_bw() + 
  theme(axis.line = element_line(colour = "black"),
        axis.text = element_text(size=14),
        axis.title = element_text(size=16),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(colour = "black"),
        panel.background = element_blank()) 
distanceSourcePlot

ggsave(filename = "results/sourcexf_distance_plot.tiff",
       plot = distanceSourcePlot,
       width = 7, height = 7, units = "in")



#### Plot of xf_vector vs xf_source_plant
plot(-10, -10,
     xlim = range(data$xf_source_plant, na.rm = TRUE),
     ylim = range(data$xf_vector, na.rm = TRUE),
     xlab = 'Predicted Source Plant xf Concentration', ylab = 'Predicted Vector xf Concentration')
points(data$xf_source_plant[dsf_ind], y = data$xf_vector[dsf_ind], col = 'blue', pch = 4)
points(data$xf_source_plant[wt_ind],  y = data$xf_vector[wt_ind],  col = 'red',  pch = 4)
abline(lm(xf_vector_med ~ xf_plant_med, data = pred_df_dsf), col = 'blue')
abline(lm(xf_vector_med ~ xf_plant_med, data = pred_df_wt),  col = 'red')
legend(legend = c('DSF', 'WT'), 'topleft', col = c('blue', 'red'), lty = 1)

## In ggplot
pred_nz2 <- pred_nz %>% dplyr::filter(xf_vector_log10 > 0)

sourceVectorPlot <- ggplot(data = pred_df) +
  geom_point(data = pred_df[pred_df$genotype == "WT",], 
             aes(y = xf_vector, x = xf_source_plant), size = 4, pch = 16) +
  geom_point(data = pred_df[pred_df$genotype == "DSF",], 
             aes(y = xf_vector, x = xf_source_plant), size = 4, pch = 1) +
  stat_smooth(data = pred_df[pred_df$genotype == "WT",],
              aes(y = xf_vector_med, x = xf_plant_med), method = "lm", se = FALSE, col = "black", lty = 1) +
  stat_smooth(data = pred_df[pred_df$genotype == "DSF",],
              aes(y = xf_vector_med, x = xf_plant_med), method = "lm", se = FALSE, col = "black", lty = 2) +
  xlab("Xylella populations in source plants (CFU/g, log10)") + ylab("Xylella populations in vectors (CFU, log10)") + 
  theme_bw() + 
  theme(axis.line = element_line(colour = "black"),
        axis.text = element_text(size=14),
        axis.title = element_text(size=16),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(colour = "black"),
        panel.background = element_blank()) 
sourceVectorPlot


sourceVectorPlot <- ggplot(data = pred_df) +
  geom_point(data = pred_df[pred_df$genotype == "WT",], 
             aes(y = xf_vector_log10, x = xf_source_log10), size = 4, pch = 16) +
  geom_point(data = pred_df[pred_df$genotype == "DSF",], 
             aes(y = xf_vector_log10, x = xf_source_log10), size = 4, pch = 1) +
  stat_smooth(data = pred_df[pred_df$genotype == "WT",],
              aes(y = xf_vector_med_log10, x = xf_plant_med_log10), method = "lm", se = FALSE, fullrange = TRUE, col = "black", lty = 1) +
  stat_smooth(data = pred_df[pred_df$genotype == "DSF",],
              aes(y = xf_vector_med_log10, x = xf_plant_med_log10), method = "lm", se = FALSE, fullrange = TRUE, col = "black", lty = 2) +
  xlab("Xylella populations in source plants (CFU/g, log10)") + ylab("Xylella populations in vectors (CFU, log10)") + ylim(c(0,5)) +
  theme_bw() + 
  theme(axis.line = element_line(colour = "black"),
        axis.text = element_text(size=14),
        axis.title = element_text(size=16),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(colour = "black"),
        panel.background = element_blank()) 
sourceVectorPlot

ggsave(filename = "results/sourcexf_distance_plot.tiff",
       plot = distanceSourcePlot,
       width = 7, height = 7, units = "in")

```

\   

##### Posterior densities of all model parameters 

\   

```{r, eval = FALSE}
plot(coda::as.mcmc(samples[[1]]), ask = FALSE)
```


```{r, echo = FALSE}
for(i in 1:5) {
    plot(coda::as.mcmc(samples[[1]][, (3*i-2):(3*i)]), ask = FALSE)
}
plot(coda::as.mcmc(samples[[1]][, 16:17]), ask = FALSE)
plot(coda::as.mcmc(samples[[1]][, 18:19]), ask = FALSE)
```



### References

\   


```{r eval=FALSE, include=FALSE}
rng <- range(samples[[1]][, Rmodel$expandNodeNames('lambda_vector')])
par(mfrow=c(2,1)), mar=c(1,1,1,1))
ymax <- 0.03
makePolygons <- function(ind, data, samples) {
    for(i in ind) {
        dens <- density(samples[[1]][, paste0('lambda_vector[',i,']')])
        color <- if(data$infected[i]) 'red' else 'black'
        polygon(x=dens$x, y=dens$y, border=color)
    }
}
plot(0,0, xlim=rng, ylim=c(0,ymax), main='Genotype DSF', xlab='lambda_vector', ylab='posterior density')
ind <- which(!is.na(data$infected) & constants$genotype_dsf)
makePolygons(ind, data, samples)
plot(0,0, xlim=rng, ylim=c(0,ymax), main='Genotype WT',  xlab='lambda_vector', ylab='posterior density')
ind <- which(!is.na(data$infected) & constants$genotype_wt)
makePolygons(ind, data, samples)




rng <- range(c(
    as.numeric(samples[[1]][, Rmodel$expandNodeNames('lambda_vector')]),
    as.numeric(na.omit(data$xf_vector))
))
par(mfrow=c(2,1)), mar=c(1,1,1,1))
ymax <- 0.03
pointsY <- 0
pch <- 19
makePolygons <- function(ind, data, samples) {
    for(i in ind) {
        dens <- density(samples[[1]][, paste0('lambda_vector[',i,']')])
        color <- if(data$infected[i]) 'red' else 'black'
        polygon(x=dens$x, y=dens$y, border=color)
    }
}
plot(0,0, xlim=rng, ylim=c(0,ymax), main='Genotype DSF', xlab='lambda_vector', ylab='posterior density')
ind <- which(!is.na(data$infected) & constants$genotype_dsf)
makePolygons(ind, data, samples)
ind <- which(!is.na(data$xf_vector) & !is.na(data$infected) & constants$genotype_dsf)
points(x=data$xf_vector[ind], y=rep(pointsY,length(ind)), pch=pch, col = ifelse(data$infected[ind], 'red', 'black'))


plot(0,0, xlim=rng, ylim=c(0,ymax), main='Genotype WT',  xlab='lambda_vector', ylab='posterior density')
ind <- which(!is.na(data$infected) & constants$genotype_wt)
makePolygons(ind, data, samples)
ind <- which(!is.na(data$xf_vector) & !is.na(data$infected) & constants$genotype_wt)
points(x=data$xf_vector[ind], y=rep(pointsY,length(ind)), pch=pch, col = ifelse(data$infected[ind], 'red', 'black'))



library(coda)
apply(samples, 2, length)
apply(samples, 2, mean)
apply(samples, 2, effectiveSize)

cor(samples)   ## b[5] and b[6] correlated

burn <- 0
burn <- 1000
burn <- 5000
burn <- 50000
samplesPlot(samples)
samplesPlot(samples, 'b[1]', burnin=burn)   ## slow mixing b[1]
samplesPlot(samples, 'b[2]', burnin=burn)   ## slow mixing b[2]
samplesPlot(samples, 'b[3]', burnin=burn)
samplesPlot(samples, 'b[4]', burnin=burn)
samplesPlot(samples, 'b[5]', burnin=burn)
samplesPlot(samples, 'b[6]', burnin=burn)
samplesPlot(samples, 'k', burnin=burn)      ## slow mixing k ??
##samplesPlot(samples, 'k2', burnin=burn)      ## slow mixing k ??
samplesPlot(samples, 'p_obs_plant', burnin=burn)
samplesPlot(samples, 'p_obs_vector', burnin=burn)
samplesPlot(samples, 'sigma_alpha', burnin=burn)


codamcmc <- runMCMC(Cmcmc, 50000, nburnin=10000, nchains=3, returnCodaMCMC=TRUE)
coda::gelman.diag(codamcmc, autoburnin = FALSE)




colnames(samples)
samplesPlot(samples, 1)  ## slow mixing b[1]
samplesPlot(samples, 2)  ## slow mixing b[2] 
samplesPlot(samples, 3)
samplesPlot(samples, 4)
samplesPlot(samples, 5)
samplesPlot(samples, 6)
samplesPlot(samples, 7)  ## slow mixing k
samplesPlot(samples, 8)
samplesPlot(samples, 9)
samplesPlot(samples, 10)




if(FALSE) {
    ## pcr data, possibly to use later
    pcr <- readRDS('data/xf_vector_population_pcr_data.rds')  ## new file with the replicated bacteria counts for vectors
    str(pcr)
    head(pcr, 15)
    dim(pcr)
    ## We use quantitative PCR (qPCR), which means we are estimating the number of copies of a gene fragment specific to the bacteria in the tissues of the insect vector. We extract all the DNA from each insect, then take two small samples of the extract and run qPCR in duplicate. The xf_vector numbers that I sent you is actually the mean of the two duplicate qPCR runs for each sample. I've attached the data showing the duplicates. The "sample" column is the ID of the insect vector, "rep1" and "rep2" are the replicates of the counts of bacteria, and "mean_xf_vector" is the mean of rep1 and rep2, and also the data that is in the "xf_vector" variable I sent you earlier.  As you can see, replicates for each vector are either both 0 or both >0; there are only 4 vectors where one replicate is 0 and the other is >0. Additionally, when both replicates are >0, there is some variation in the estimated count between the two replicates. 
}
##


##ind <- 43
##ind <- 44
##ind <- 56
##ind <- 78
##ind <- 96
##ind <- 97
## 
##nodes <- c(
##    paste0('b[',6,']'),
##    ##'sigma_alpha', 'mu_alpha',
##    'p_obs_plant', 'p_obs_vector',
##    ##'k',
##    paste0('z_obs_plant[',ind,']'),
##    paste0('z_obs_vector[',ind,']'),
##    paste0('lambda_plant[',ind,']'),
##    paste0('lambda_vector[',ind,']'),
##    paste0('p_infect[',ind,']'),
##    paste0('xf_source_plant[',ind,']'),
##    paste0('xf_vector[',ind,']'),
##    paste0('infected[',ind,']')
##)
##i <- 5000:5010
##cbind(samples[i, nodes],
##      dat_source=data$xf_source_plant[ind],
##      dat_vector=data$xf_vector[ind],
##      dat_infect=data$infected[ind])
```

